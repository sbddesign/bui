import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import ts from 'typescript';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const uiDir = path.resolve(__dirname, '../../ui');
const outputJsonFile = path.resolve(__dirname, '../generated/components.json');
const outputTsFile = path.resolve(__dirname, '../src/generated/components-data.ts');

interface ComponentAttribute {
  property: string;
  attribute: string;
  type: string;
  reflects: boolean;
  required: boolean;
  default?: string | number | boolean | null;
  values?: string[];
  notes?: string;
}

interface ComponentMeta {
  name: string;
  tagName: string;
  className: string;
  source: string;
  description: string;
  attributes: ComponentAttribute[];
  events: string[];
}

async function main() {
  const files = await fs.readdir(uiDir);
  const components: ComponentMeta[] = [];

  for (const file of files) {
    if (!file.endsWith('.ts') || file.endsWith('.d.ts')) continue;
    const fullPath = path.join(uiDir, file);
    const content = await fs.readFile(fullPath, 'utf8');
    if (!content.includes('customElements.define')) continue;
    const parsed = parseComponent(fullPath, content);
    if (parsed) {
      components.push(parsed);
    }
  }

  components.sort((a, b) => a.name.localeCompare(b.name));

  const previous = await readExistingDataset();
  const serialized = JSON.stringify(components);
  const generatedAt =
    previous && JSON.stringify(previous.components) === serialized
      ? previous.generatedAt
      : new Date().toISOString();

  const payload = {
    generatedAt,
    components,
  };

  await fs.mkdir(path.dirname(outputJsonFile), { recursive: true });
  await fs.mkdir(path.dirname(outputTsFile), { recursive: true });
  await fs.writeFile(outputJsonFile, JSON.stringify(payload, null, 2));
  await fs.writeFile(
    outputTsFile,
    `// AUTO-GENERATED BY generate-mcp-data.ts\n` +
      `export const dataset = ${JSON.stringify(payload, null, 2)} as const;\n` +
      `export default dataset;\n`
  );
  console.log(`Generated metadata for ${components.length} components.`);
}

async function readExistingDataset(): Promise<{
  generatedAt: string;
  components: ComponentMeta[];
} | null> {
  try {
    const buffer = await fs.readFile(outputJsonFile, 'utf8');
    return JSON.parse(buffer);
  } catch {
    return null;
  }
}

function parseComponent(filePath: string, content: string): ComponentMeta | null {
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.ESNext,
    true,
    ts.ScriptKind.TS
  );

  const classDecl = sourceFile.statements.find(
    (statement): statement is ts.ClassDeclaration =>
      ts.isClassDeclaration(statement) && !!statement.name && extendsLitElement(statement)
  );

  if (!classDecl || !classDecl.name) {
    console.warn(`Skipping ${path.basename(filePath)}: LitElement class not found.`);
    return null;
  }

  const className = classDecl.name.text;
  const tagName = extractTagName(sourceFile, className);
  if (!tagName) {
    console.warn(`Skipping ${path.basename(filePath)}: customElements.define call not found.`);
    return null;
  }

  const literalSets = collectLiteralSets(sourceFile);
  const allowedValues = collectAllowedValues(sourceFile, literalSets);
  const defaults = collectDefaults(classDecl);
  const attributes = collectAttributes(classDecl, allowedValues, defaults);
  const events = collectEvents(sourceFile);

  return {
    name: friendlyName(className),
    tagName,
    className,
    source: `packages/ui/${path.basename(filePath)}`,
    description: `Metadata for ${className} (${tagName}) generated from source.`,
    attributes,
    events,
  };
}

function extendsLitElement(node: ts.ClassDeclaration): boolean {
  if (!node.heritageClauses) return false;
  return node.heritageClauses.some((clause) =>
    clause.types.some(
      (type) =>
        ts.isExpressionWithTypeArguments(type) &&
        ts.isIdentifier(type.expression) &&
        type.expression.text === 'LitElement'
    )
  );
}

function extractTagName(sourceFile: ts.SourceFile, className: string): string | null {
  let tagName: string | null = null;

  const visit = (node: ts.Node) => {
    if (
      ts.isCallExpression(node) &&
      ts.isPropertyAccessExpression(node.expression) &&
      node.expression.expression.getText() === 'customElements' &&
      node.expression.name.getText() === 'define'
    ) {
      const [tagArg, classArg] = node.arguments;
      if (tagArg && ts.isStringLiteral(tagArg) && classArg && classArg.getText() === className) {
        tagName = tagArg.text;
        return;
      }
    }
    if (!tagName) {
      ts.forEachChild(node, visit);
    }
  };

  ts.forEachChild(sourceFile, visit);
  return tagName;
}

function collectLiteralSets(sourceFile: ts.SourceFile): Map<string, string[]> {
  const map = new Map<string, string[]>();

  for (const statement of sourceFile.statements) {
    if (!ts.isVariableStatement(statement)) continue;
    if (!(statement.declarationList.flags & ts.NodeFlags.Const)) continue;

    for (const declaration of statement.declarationList.declarations) {
      if (!declaration.name || !ts.isIdentifier(declaration.name) || !declaration.initializer)
        continue;
      const arrayLiteral = unwrapExpression(declaration.initializer);
      if (!ts.isArrayLiteralExpression(arrayLiteral)) continue;

      const values: string[] = [];
      let valid = true;
      for (const element of arrayLiteral.elements) {
        const value = evaluateLiteral(element);
        if (typeof value === 'string') {
          values.push(value);
        } else {
          valid = false;
          break;
        }
      }

      if (valid && values.length) {
        map.set(declaration.name.text, values);
      }
    }
  }

  return map;
}

function collectAllowedValues(
  sourceFile: ts.SourceFile,
  literalSets: Map<string, string[]>
): Map<string, string[]> {
  const allowed = new Map<string, string[]>();

  const visit = (node: ts.Node) => {
    if (
      ts.isCallExpression(node) &&
      ts.isIdentifier(node.expression) &&
      node.expression.text === 'createStringLiteralValidationRule'
    ) {
      const [valueArg, propertyArg] = node.arguments;
      const identifier = valueArg ? getIdentifier(valueArg) : undefined;
      if (identifier && propertyArg && ts.isStringLiteral(propertyArg)) {
        const literals = literalSets.get(identifier);
        if (literals) {
          allowed.set(propertyArg.text, literals);
        }
      }
    }
    ts.forEachChild(node, visit);
  };

  ts.forEachChild(sourceFile, visit);
  return allowed;
}

function collectDefaults(
  classDecl: ts.ClassDeclaration
): Map<string, string | number | boolean | null> {
  const map = new Map<string, string | number | boolean | null>();
  const constructor = classDecl.members.find((member): member is ts.ConstructorDeclaration =>
    ts.isConstructorDeclaration(member)
  );

  if (!constructor || !constructor.body) return map;

  for (const statement of constructor.body.statements) {
    if (!ts.isExpressionStatement(statement)) continue;
    if (!ts.isBinaryExpression(statement.expression)) continue;
    if (statement.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken) continue;
    if (!ts.isPropertyAccessExpression(statement.expression.left)) continue;
    if (statement.expression.left.expression.kind !== ts.SyntaxKind.ThisKeyword) continue;

    const propertyName = statement.expression.left.name.getText();
    const value = evaluateLiteral(statement.expression.right);
    if (value !== undefined) {
      map.set(propertyName, value as string | number | boolean | null);
    }
  }

  return map;
}

function collectAttributes(
  classDecl: ts.ClassDeclaration,
  allowedValues: Map<string, string[]>,
  defaults: Map<string, string | number | boolean | null>
): ComponentAttribute[] {
  const propertyDeclaration = classDecl.members.find(
    (member): member is ts.PropertyDeclaration =>
      ts.isPropertyDeclaration(member) &&
      member.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.StaticKeyword) &&
      member.name.getText() === 'properties'
  );

  if (!propertyDeclaration || !propertyDeclaration.initializer) {
    return [];
  }

  const initializer = unwrapExpression(propertyDeclaration.initializer);
  if (!ts.isObjectLiteralExpression(initializer)) {
    return [];
  }

  const attributes: ComponentAttribute[] = [];

  for (const property of initializer.properties) {
    if (!ts.isPropertyAssignment(property)) continue;
    const propertyName = getPropertyName(property.name);
    if (!propertyName) continue;

    const descriptor = unwrapExpression(property.initializer);
    if (!ts.isObjectLiteralExpression(descriptor)) continue;

    const attributeMeta: ComponentAttribute = {
      property: propertyName,
      attribute: toKebabCase(propertyName),
      type: 'string',
      reflects: false,
      required: !defaults.has(propertyName),
    };

    for (const field of descriptor.properties) {
      if (!ts.isPropertyAssignment(field)) continue;
      const fieldName = getPropertyName(field.name);
      if (!fieldName) continue;
      const value = unwrapExpression(field.initializer);

      switch (fieldName) {
        case 'type': {
          attributeMeta.type = mapType(value);
          break;
        }
        case 'attribute': {
          const literal = evaluateLiteral(value);
          if (typeof literal === 'string' && literal.length) {
            attributeMeta.attribute = literal;
          }
          break;
        }
        case 'reflect': {
          const literal = evaluateLiteral(value);
          attributeMeta.reflects = literal === true;
          break;
        }
        case 'converter': {
          attributeMeta.notes = 'Uses custom converter.';
          break;
        }
        default:
          break;
      }
    }

    if (defaults.has(propertyName)) {
      attributeMeta.default = defaults.get(propertyName);
    }

    if (allowedValues.has(propertyName)) {
      attributeMeta.values = allowedValues.get(propertyName);
    }

    attributes.push(attributeMeta);
  }

  return attributes;
}

function collectEvents(sourceFile: ts.SourceFile): string[] {
  const events = new Set<string>();

  const visit = (node: ts.Node) => {
    if (
      ts.isNewExpression(node) &&
      ts.isIdentifier(node.expression) &&
      node.expression.text === 'CustomEvent' &&
      node.arguments &&
      node.arguments.length > 0
    ) {
      const [nameArg] = node.arguments;
      if (ts.isStringLiteral(nameArg)) {
        events.add(nameArg.text);
      }
    }
    ts.forEachChild(node, visit);
  };

  ts.forEachChild(sourceFile, visit);
  return Array.from(events);
}

function unwrapExpression<T extends ts.Expression>(expression: T): ts.Expression {
  if (ts.isAsExpression(expression) || ts.isTypeAssertionExpression(expression)) {
    return unwrapExpression(expression.expression as ts.Expression);
  }
  if (ts.isNonNullExpression(expression)) {
    return unwrapExpression(expression.expression);
  }
  if (ts.isParenthesizedExpression(expression)) {
    return unwrapExpression(expression.expression);
  }
  return expression;
}

function evaluateLiteral(node: ts.Expression): string | number | boolean | null | undefined {
  const expression = unwrapExpression(node);

  if (ts.isStringLiteralLike(expression)) {
    return expression.text;
  }
  if (ts.isNumericLiteral(expression)) {
    return Number(expression.text);
  }
  if (expression.kind === ts.SyntaxKind.TrueKeyword) {
    return true;
  }
  if (expression.kind === ts.SyntaxKind.FalseKeyword) {
    return false;
  }
  if (expression.kind === ts.SyntaxKind.NullKeyword) {
    return null;
  }
  if (
    ts.isPrefixUnaryExpression(expression) &&
    expression.operator === ts.SyntaxKind.MinusToken &&
    ts.isNumericLiteral(expression.operand)
  ) {
    return -Number(expression.operand.text);
  }
  return undefined;
}

function getIdentifier(expression: ts.Expression): string | undefined {
  const unwrapped = unwrapExpression(expression);
  if (ts.isIdentifier(unwrapped)) {
    return unwrapped.text;
  }
  return undefined;
}

function getPropertyName(name: ts.PropertyName): string | undefined {
  if (ts.isIdentifier(name) || ts.isStringLiteral(name) || ts.isNumericLiteral(name)) {
    return name.text.toString();
  }
  return undefined;
}

function mapType(value: ts.Expression): string {
  const expression = unwrapExpression(value);
  if (ts.isIdentifier(expression)) {
    switch (expression.text) {
      case 'Boolean':
        return 'boolean';
      case 'Number':
        return 'number';
      case 'String':
        return 'string';
      case 'Object':
        return 'object';
      default:
        return expression.text.toLowerCase();
    }
  }
  return 'string';
}

function friendlyName(className: string): string {
  return className
    .replace(/^Bui/, '')
    .replace(/([a-z])([A-Z])/g, (_, a, b) => `${a} ${b}`)
    .trim();
}

function toKebabCase(value: string): string {
  return value
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/_/g, '-')
    .toLowerCase();
}

await main();
